# Expanding paths from Schemas

## Schema -> Path

This is a function to extract the full paths from a runtime schema. This will let us build 
a tree schema that can then be used for the reduced simple_form implementation.

<!-- livebook:{"break_markdown":true} -->

These are the fields. We can also generate this from compile time schemas (it's an expanded runtime 
schema)

```elixir
IEx.Helpers.recompile()
```

```elixir
fields = [
  field:
    {:response_sid,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "ShoppingResponseID",
       "ResponseID",
       "text()"
     ], StringType},
  has_many:
    {:warnings,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "Warnings",
       "Warning"
     ],
     {Warning,
      [
        field: {:code, ["Warning", "@Code"], StringType, [optional?: true]},
        field: {:owner, ["Warning", "@Owner"], StringType, [optional?: true]},
        field: {:type, ["Warning", "@Type"], StringType, [optional?: true]},
        field: {:title, ["Warning", "@ShortText"], StringType, [optional?: true]},
        field: {:description, ["Warning", "text()"], StringType, [optional?: true]}
      ]}},
  has_many:
    {:errors,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "Errors",
       "Error"
     ],
     {Error,
      [
        field: {:code, ["Error", "@Code"], StringType, [optional?: true]},
        field: {:sid, ["Error", "@Owner"], StringType, [optional?: true]},
        field: {:status, ["Error", "@Status"], StringType, [optional?: true]},
        field: {:type, ["Error", "@Type"], StringType, [optional?: true]},
        field: {:title, ["Error", "@ShortText"], StringType, [optional?: true]},
        field: {:description, ["Error", "text()"], StringType, [optional?: true]}
      ]}, [optional?: true]},
  has_many:
    {:baggage_allowances,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "DataLists",
       "BaggageAllowanceList",
       "BaggageAllowance"
     ],
     {BaggageAllowance,
      [
        field: {:sid, ["BaggageAllowance", "@BaggageAllowanceID"], StringType},
        field:
          {:baggage_determining_carrier_code,
           ["BaggageAllowance", "BaggageDeterminingCarrier", "AirlineID", "text()"], StringType},
        field: {:category, ["BaggageCategory", "text()"], Downcase, [optional?: true]},
        field:
          {:descriptions,
           [
             "BaggageAllowance",
             "AllowanceDescription",
             "Descriptions",
             "Description",
             "Text",
             "text()"
           ], StringType, [optional?: true]},
        has_one:
          {:piece_allowances, ["BaggageAllowance", "PieceAllowance"],
           {PieceAllowance,
            [
              field:
                {:applicable_bag, ["PieceAllowance", "ApplicableBag", "text()"], StringType,
                 [optional?: true]},
              field:
                {:applicable_party, ["PieceAllowance", "ApplicableParty", "text()"], Downcase},
              field:
                {:total_quantity, ["PieceAllowance", "TotalQuantity", "text()"], IntegerType,
                 [optional?: true]},
              has_many:
                {:weights, ["PieceAllowance", "PieceMeasurements", "PieceWeightAllowance"],
                 {Weight,
                  [
                    field:
                      {:maximum_weight,
                       ["PieceWeightAllowance", "MaximumWeight", "Value", "text()"], Downcase},
                    field:
                      {:maximum_weight_uom,
                       ["PieceWeightAllowance", "MaximumWeight", "UOM", "text()"], Downcase}
                  ]}, [optional?: true]},
              has_many:
                {:dimensions, ["PieceAllowance", "PieceMeasurements", "PieceDimensionAllowance"],
                 {Dimension,
                  [
                    field:
                      {:uom, ["PieceDimensionAllowance", "DimensionUOM", "text()"], Downcase},
                    field:
                      {:category, ["PieceDimensionAllowance", "Dimensions", "Category", "text()"],
                       Downcase},
                    field:
                      {:max, ["PieceDimensionAllowance", "Dimensions", "MaxValue", "text()"],
                       StringType}
                  ]}, [optional?: true]}
            ]}, [optional?: true]},
        has_many:
          {:weight_allowances, ["BaggageAllowance", "WeightAllowance"],
           {WeightAllowance,
            [
              field:
                {:applicable_party, ["WeightAllowance", "ApplicableParty", "text()"], Downcase,
                 [optional?: true]},
              has_many:
                {:weights, ["WeightAllowance", "MaximumWeight"],
                 {MaxWeight,
                  [
                    field: {:maximum_weight, ["MaximumWeight", "Value", "text()"], Downcase},
                    field: {:maximum_weight_uom, ["MaximumWeight", "UOM", "text()"], Downcase}
                  ]}}
            ]}, [optional?: true]}
      ]}, [optional?: true]},
  list_of:
    {:currency_metadata,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "Metadata",
       "Other",
       "OtherMetadata",
       "CurrencyMetadatas"
     ], CurrencyMetadata, [optional?: true]},
  has_many:
    {:fare_groups,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "DataLists",
       "FareList",
       "FareGroup"
     ],
     {FareGroup,
      [
        field: {:sid, ["FareGroup", "@ListKey"], StringType, [optional?: true]},
        field:
          {:fare_code, ["FareGroup", "Fare", "FareCode", "text()"], StringType, [optional?: true]},
        field:
          {:fare_basis_code, ["FareGroup", "FareBasisCode", "Code", "text()"], StringType,
           [optional?: true]}
      ]}, [optional?: true]},
  has_many:
    {:journeys,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "DataLists",
       "FlightList",
       "Flight"
     ],
     {Journey,
      [
        field: {:sid, ["Flight", "@FlightKey"], &Journey.trim/1, [optional?: true]},
        field:
          {:duration, ["Flight", "Journey", "Time", "text()"], BlankAsNil, [optional?: true]},
        field:
          {:segments, ["Flight", "SegmentReferences", "text()"], StringSplitOnSpace,
           [optional?: true]}
      ]}, [optional?: true]},
  list_of:
    {:rule_metadata,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "Metadata",
       "Other",
       "OtherMetadata",
       "RuleMetadatas"
     ], RuleMetadata, [optional?: true]},
  has_many:
    {:offers,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "OffersGroup",
       "AirlineOffers",
       "Offer"
     ],
     {Offer,
      [
        has_many:
          {:baggage_allowances, ["Offer", "BaggageAllowance"],
           {OfferBaggageAllowance,
            [
              field:
                {:baggage_allowance_sid, ["BaggageAllowance", "BaggageAllowanceRef", "text()"],
                 StringType, [optional?: true]},
              field:
                {:journey_sids, ["BaggageAllowance", "FlightRefs", "text()"], StringSplitOnSpace,
                 [optional?: true]},
              field:
                {:passenger_ids, ["BaggageAllowance", "PassengerRefs", "text()"],
                 StringSplitOnSpace, [optional?: true]}
            ]}, [optional?: true]},
        field:
          {:base_amount, ["Offer", "NotImplemented", "text()"], StringType, [optional?: true]},
        field:
          {:base_currency, ["Offer", "NotImplemented", "text()"], StringType, [optional?: true]},
        has_many:
          {:journeys, ["Offer", "FlightsOverview", "FlightRef"],
           {OfferJourney,
            [
              field: {:sid, ["FlightRef", "text()"], &OfferJourney.trim/1, [optional?: true]},
              field:
                {:origin_destination_sid, ["FlightRef", "@ODRef"], StringType, [optional?: true]},
              field:
                {:price_class_sid, ["FlightRef", "@PriceClassRef"], StringType, [optional?: true]}
            ]}},
        field: {:owner_iata_code, ["Offer", "@Owner"], StringType},
        field:
          {:price_guaranteed_by,
           [
             "Offer",
             "TimeLimits",
             "OtherLimits",
             "OtherLimit",
             "PriceGuaranteeTimeLimit",
             "PriceGuarantee",
             "text()"
           ], StringType, [optional?: true]},
        field: {:sid, ["Offer", "@OfferID"], StringType},
        field:
          {:tax_amount,
           ["Offer", "TotalPrice", "DetailCurrencyPrice", "Taxes", "Total", "text()"],
           DecimalType, [optional?: true]},
        field:
          {:tax_currency,
           ["Offer", "TotalPrice", "DetailCurrencyPrice", "Taxes", "Total", "@Code"], StringType,
           [optional?: true]},
        field:
          {:ticket_by,
           [
             "Offer",
             "TimeLimits",
             "OtherLimits",
             "OtherLimit",
             "TicketByTimeLimit",
             "TicketBy",
             "text()"
           ], StringType, [optional?: true]},
        field:
          {:expires_at, ["Offer", "TimeLimits", "OfferExpiration", "@DateTime"], StringType,
           [optional?: true]},
        field:
          {:total_amount, ["Offer", "TotalPrice", "DetailCurrencyPrice", "Total", "text()"],
           DecimalType},
        field:
          {:total_currency, ["Offer", "TotalPrice", "DetailCurrencyPrice", "Total", "@Code"],
           StringType},
        field:
          {:fare_type, ["Offer", "Match", "MatchResult", "text()"], StringType, [optional?: true]},
        has_many:
          {:items, ["Offer", "OfferItem"],
           {OfferItem,
            [
              field:
                {:base_amount, ["OfferItem", "NotImplemented", "text()"], DecimalType,
                 [optional?: true]},
              field:
                {:base_currency, ["OfferItem", "NotImplemented", "text()"], StringType,
                 [optional?: true]},
              field: {:mandatory, ["OfferItem", "@MandatoryInd"], Boolean, [optional?: true]},
              field: {:sid, ["OfferItem", "@OfferItemID"], StringType, [optional?: true]},
              field:
                {:tax_amount, ["OfferItem", "NotImplemented", "text()"], DecimalType,
                 [optional?: true]},
              field:
                {:tax_currency, ["OfferItem", "NotImplemented", "text()"], StringType,
                 [optional?: true]},
              field:
                {:total_amount,
                 [
                   "OfferItem",
                   "TotalPriceDetail",
                   "TotalAmount",
                   "DetailCurrencyPrice",
                   "Total",
                   "text()"
                 ], DecimalType, [optional?: true]},
              field:
                {:total_currency,
                 [
                   "OfferItem",
                   "TotalPriceDetail",
                   "TotalAmount",
                   "DetailCurrencyPrice",
                   "Total",
                   "@Code"
                 ], StringType, [optional?: true]},
              has_many:
                {:fare_details, ["OfferItem", "FareDetail"],
                 {FareDetail,
                  [
                    field:
                      {:fare_indicator_code, ["FareDetail", "FareIndicatorCode", "text()"],
                       StringType, [optional?: true]},
                    field:
                      {:passenger_sids, ["FareDetail", "PassengerRefs", "text()"],
                       StringSplitOnSpace, [optional?: true]},
                    list_of:
                      {:remarks, ["FareDetail", "Remarks", "Remark", "text()"], StringType,
                       [optional?: true]},
                    has_many:
                      {:fare_components, ["FareDetail", "FareComponent"],
                       {FareComponent,
                        [
                          field:
                            {:booking_classes, ["FareComponent", "FareBasis", "RBD", "text()"],
                             StringSplitOnSpace, [optional?: true]},
                          field:
                            {:cabin_class_codes,
                             [
                               "FareComponent",
                               "FareBasis",
                               "CabinType",
                               "CabinTypeCode",
                               "text()"
                             ], StringSplitOnSpace, [optional?: true]},
                          field:
                            {:cabin_class_marketing_names,
                             [
                               "FareComponent",
                               "FareBasis",
                               "CabinType",
                               "CabinTypeName",
                               "text()"
                             ], StringSplitOnSpace, [optional?: true]},
                          field:
                            {:fare_basis_code,
                             ["FareComponent", "FareBasis", "FareBasisCode", "Code", "text()"],
                             StringType, [optional?: true]},
                          field:
                            {:ticket_desig, ["FareComponent", "TicketDesig", "text()"],
                             StringType, [optional?: true]},
                          field:
                            {:fare_basis_reference,
                             ["FareComponent", "FareBasis", "FareBasisCode", "@refs"], StringType,
                             [optional?: true]},
                          field:
                            {:fare_basis_city_pair,
                             ["FareComponent", "FareBasis", "FareBasisCityPair", "text()"],
                             StringType, [optional?: true]},
                          field:
                            {:fare_group_sids,
                             ["FareComponent", "FareBasis", "FareBasisCode", "@refs"],
                             StringSplitOnSpace, [optional?: true]},
                          has_one:
                            {:fare_rules, ["FareComponent", "FareRules"],
                             {FareRule,
                              [
                                list_of:
                                  {:ticketing_endorsements,
                                   [
                                     "FareRules",
                                     "Ticketing",
                                     "Endorsements",
                                     "Endorsement",
                                     "text()"
                                   ], StringType, [optional?: true]},
                                field:
                                  {:penalty_sids, ["FareRules", "Penalty", "@refs"],
                                   StringSplitOnSpace, [optional?: true]},
                                has_many:
                                  {:details, ["FareRules", "Penalty", "Details", "Detail"],
                                   {FareRuleDetail,
                                    [
                                      field:
                                        {:metadata_rule_ref, ["Detail", "@refs"], StringType,
                                         [optional?: true]},
                                      field:
                                        {:type, ["Detail", "Type", "text()"], StringType,
                                         [optional?: true]}
                                    ]}, [optional?: true]}
                              ]}, [optional?: true]},
                          field:
                            {:price_class_sid, ["FareComponent", "PriceClassRef", "text()"],
                             StringType, [optional?: true]},
                          field:
                            {:segment_sids, ["FareComponent", "SegmentRefs", "text()"],
                             StringSplitOnSpace, [optional?: true]},
                          has_one:
                            {:price, ["FareComponent", "Price"],
                             {FareComponentPrice,
                              [
                                field:
                                  {:base_amount, ["Price", "BaseAmount", "text()"], DecimalType,
                                   [optional?: true]},
                                field:
                                  {:base_currency, ["Price", "BaseAmount", "@Code"], StringType,
                                   [optional?: true]},
                                field:
                                  {:filed_base_amount,
                                   ["Price", "FareFiledIn", "BaseAmount", "text()"], DecimalType,
                                   [optional?: true]},
                                field:
                                  {:filed_base_currency,
                                   ["Price", "FareFiledIn", "BaseAmount", "@Code"], StringType,
                                   [optional?: true]},
                                field:
                                  {:filed_base_nuc,
                                   ["Price", "FareFiledIn", "NUCAmount", "text()"], DecimalType,
                                   [optional?: true]},
                                field:
                                  {:filed_exchange_rate,
                                   ["Price", "FareFiledIn", "ExchangeRate", "text()"], StringType,
                                   [optional?: true]},
                                field:
                                  {:tax_amount, ["Price", "Taxes", "Total", "text()"],
                                   DecimalType, [optional?: true]},
                                field:
                                  {:tax_currency, ["Price", "Taxes", "Total", "@Code"],
                                   StringType, [optional?: true]},
                                has_many:
                                  {:taxes, ["Price", "Taxes", "Breakdown", "Tax"],
                                   {FareComponentPriceTax,
                                    [
                                      field:
                                        {:amount, ["Tax", "Amount", "text()"], DecimalType,
                                         [optional?: true]},
                                      field:
                                        {:currency, ["Tax", "Amount", "@Code"], StringType,
                                         [optional?: true]},
                                      field:
                                        {:curdescriptionrency, ["Tax", "Description", "text()"],
                                         StringType, [optional?: true]},
                                      field:
                                        {:local_amount, ["Tax", "LocalAmount", "text()"],
                                         DecimalType, [optional?: true]},
                                      field:
                                        {:local_currency, ["Tax", "LocalAmount", "@Code"],
                                         StringType, [optional?: true]},
                                      field:
                                        {:nation_code, ["Tax", "Nation", "text()"], StringType,
                                         [optional?: true]},
                                      field:
                                        {:tax_code, ["Tax", "TaxCode", "text()"], StringType,
                                         [optional?: true]}
                                    ]}, [optional?: true]}
                              ]}, [optional?: true]}
                        ]}, [optional?: true]}
                  ]}, [optional?: true]},
              has_many:
                {:services, ["OfferItem", "Service"],
                 {OfferItemService,
                  [
                    field:
                      {:journey_sids, ["Service", "FlightRefs", "text()"], StringSplitOnSpace,
                       [optional?: true]},
                    field:
                      {:passenger_sids, ["Service", "PassengerRefs", "text()"],
                       StringSplitOnSpace, [optional?: true]},
                    field:
                      {:segment_sids, ["Service", "ServiceDefinitionRef", "@SegmentRefs"],
                       StringSplitOnSpace, [optional?: true]},
                    field:
                      {:service_definition_sid, ["Service", "ServiceDefinitionRef", "text()"],
                       StringType, [optional?: true]},
                    field:
                      {:service_sid, ["Service", "ServiceRef", "text()"], StringType,
                       [optional?: true]},
                    field: {:sid, ["Service", "@ServiceID"], StringType, [optional?: true]}
                  ]}, [optional?: true]}
            ]}, [optional?: true]}
      ]}, [optional?: true]},
  has_many:
    {:origin_destinations,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "DataLists",
       "OriginDestinationList",
       "OriginDestination"
     ],
     {OriginDestination,
      [
        field:
          {:departure_code, ["OriginDestination", "DepartureCode", "text()"], StringType,
           [optional?: true]},
        field:
          {:arrival_code, ["OriginDestination", "ArrivalCode", "text()"], StringType,
           [optional?: true]},
        field:
          {:journeys, ["OriginDestination", "FlightReferences", "text()"], StringSplitOnSpace,
           [optional?: true]},
        field:
          {:sid, ["OriginDestination", "@OriginDestinationKey"], StringType, [optional?: true]}
      ]}, [optional?: true]},
  has_many:
    {:passengers,
     [
       "SOAP-ENV:Envelope",
       "SOAP-ENV:Body",
       "ns1:XXTransactionResponse",
       "RSP",
       "AirShoppingRS",
       "DataLists",
       "PassengerList",
       "Passenger"
     ],
     {Passenger,
      [
        field: {:sid, ["Passenger", "@PassengerID"], StringType, [optional?: true]},
        field:
          {:birthdate, ["Passenger", "Individual", "Birthdate", "text()"], StringType,
           [optional?: true]},
        field:
          {:family_name, ["Passenger", "Individual", "Surname", "text()"], StringType,
           [optional?: true]},
        field:
          {:gender, ["Passenger", "Individual", "Gender", "text()"], StringType,
           [optional?: true]},
        field:
          {:given_name, ["Passenger", "Individual", "GivenName", "text()"], JoinWithSpaces,
           [optional?: true]},
        field:
          {:title, ["Passenger", "Individual", "NameTitle", "text()"], StringType,
           [optional?: true]},
        field: {:type, ["Passenger", "PTC", "text()"], StringType, [optional?: true]}
      ]}, [optional?: true]}
]
```

This is the "create paths" function. It creates the full path from every field in the schema.

```elixir
defmodule Expand do
  def paths(fields, acc) do
    Enum.reduce(fields, acc, fn
      {:has_many, {_key, path, {_child_schema, child_fields}, _opts}}, acc ->
        last = List.last(path)
        path = path |> List.replace_at(-1, {:all, last})

        child_fields
        |> paths([])
        |> Enum.reduce(acc, fn p, accu ->
          [path ++ p | accu]
        end)

      {:has_many, {_key, path, {_child_schema, child_fields}}}, acc ->
        last = List.last(path)
        path = path |> List.replace_at(-1, {:all, last})

        child_fields
        |> paths([])
        |> Enum.reduce(acc, fn p, accu ->
          [path ++ p | accu]
        end)

      {:has_one, {_key, path, {_child_schema, child_fields}, _opts}}, acc ->
        path = Enum.drop(path, -1)

        child_fields
        |> paths([])
        |> Enum.reduce(acc, fn p, accu ->
          [path ++ p | accu]
        end)

      {:has_one, {_key, path, {_child_schema, child_fields}}}, acc ->
        path = Enum.drop(path, -1)

        child_fields
        |> paths([])
        |> Enum.reduce(acc, fn p, accu ->
          [path ++ p | accu]
        end)

      {_field, {_key, path, _cast_fn}}, acc ->
        [path | acc]

      {_field, {_key, path, _cast_fn, _opts}}, acc ->
        [path | acc]
    end)
  end
end

paths = Expand.paths(fields, [])
```

```elixir
sorted = Enum.sort_by(paths, & &1)
# |> IO.inspect(limit: :infinity)
```

```elixir
defmodule MapUtils do
  def deep_merge(left, right) do
    Map.merge(left, right, &deep_resolve/3)
  end

  # Key exists in both maps, and both values are maps as well.
  # These can be merged recursively.
  defp deep_resolve(_key, left = %{}, right = %{}) do
    deep_merge(left, right)
  end

  # Key exists in both maps, but at least one of the values is
  # NOT a map. We fall back to standard merge behavior, preferring
  # the value on the right.
  defp deep_resolve(_key, {:all, left}, {:all, right}) do
    {:all, deep_merge(left, right)}
  end

  defp deep_resolve(_key, {:all, _left}, _right) do
    raise "?"
  end

  defp deep_resolve(_key, _left, {:all, _right}) do
    raise "?2"
  end

  defp deep_resolve(_key, _left, right) do
    right
  end
end

defmodule Tree do
  def create(paths) do
    Enum.reduce(paths, %{}, fn path, acc ->
      map =
        path
        # |> Enum.reverse()
        |> dedup_path([])
        # |> IO.inspect(label: :deduped)
        |> Enum.reduce(%{}, fn
          "text()", _accu ->
            %{text: true}

          "@" <> attr, _accu ->
            %{{:attr, attr} => true}

          {:all, key}, accu ->
            %{key => {:all, accu}}

          key, accu ->
            %{key => accu}
        end)

      MapUtils.deep_merge(acc, map)
    end)
  end

  # dedups immediate neighbours only, also reverses the list which helps with the 
  # next steps after it.

  def dedup_path([], acc) do
    acc
  end

  def dedup_path([key], acc) do
    [key | acc]
  end

  def dedup_path([head, {:all, head} | rest], acc) do
    dedup_path([{:all, head} | rest], acc)
  end

  def dedup_path([{:all, head}, head | rest], acc) do
    dedup_path([{:all, head} | rest], acc)
  end

  def dedup_path([head, head | rest], acc) do
    # If it is duplicated then we need to drop one
    # the next will be picked up in the next iteration. 
    # I think if we have double dups this wont work, but 
    # we wont have that (I think!!)
    dedup_path([head | rest], acc)
  end

  def dedup_path([head, next | rest], acc) do
    dedup_path([next | rest], [head | acc])
  end
end

schema = Tree.create(sorted)
# |> IO.inspect(limit: :infinity)
```

```elixir
large_xml = File.read!("/Users/adz/Duffel/saxy/test/support/fixture/really_large.xml")

DataSchema.XML.Saxy.parse_string(large_xml, schema)
```
