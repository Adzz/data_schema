# Expanding paths from Schemas

## Schema -> Path

This is a function to extract the full paths from a runtime schema. This will let us build 
a tree schema that can then be used for the reduced simple_form implementation.

<!-- livebook:{"break_markdown":true} -->

These are the fields. We can also generate this from compile time schemas (it's an expanded runtime 
schema)

```elixir
IEx.Helpers.recompile()
```

```elixir
fields = DataSchema.to_runtime_schema(Duffel.Link.XMLParsing.Lufthansa.AirShopping)
```

This is the "create paths" function. It creates the full path from every field in the schema.

```elixir
defmodule Expand do
  def paths(fields, acc) do
    Enum.reduce(fields, acc, fn
      {:has_many, {_key, path, {_child_schema, child_fields}, _opts}}, acc ->
        # last = List.last(path)
        # path = path |> List.replace_at(-1, {:all, last})

        child_fields
        |> paths([])
        |> Enum.reduce(acc, fn
          {p, modifier}, accu ->
            [{path ++ p, modifier} | accu]
        end)

      {:has_many, {_key, path, {_child_schema, child_fields}}}, acc ->
        # last = List.last(path)
        # path = path |> List.replace_at(-1, {:all, last})

        child_fields
        |> paths([])
        |> Enum.reduce(acc, fn
          {p, modifier}, accu ->
            [{path ++ p, modifier} | accu]
        end)

      {:has_one, {_key, path, {_child_schema, child_fields}, _opts}}, acc ->
        # path = Enum.drop(path, -1)

        child_fields
        |> paths([])
        |> Enum.reduce(acc, fn
          {p, modifier}, accu ->
            [{path ++ p, modifier} | accu]
        end)

      {:has_one, {_key, path, {_child_schema, child_fields}}}, acc ->
        # path = Enum.drop(path, -1)

        child_fields
        |> paths([])
        |> Enum.reduce(acc, fn
          {p, modifier}, accu ->
            [{path ++ p, modifier} | accu]
        end)

      {:aggregate, {_key, child_fields, _cast_fn}}, acc ->
        paths(child_fields, acc)

      {:aggregate, {_key, child_fields, _cast_fn, _opts}}, acc ->
        paths(child_fields, acc)

      {_field, {_key, path, _cast_fn}}, acc ->
        [path | acc]

      {_field, {_key, path, _cast_fn, _opts}}, acc ->
        [path | acc]
    end)
  end
end

paths = Expand.paths(fields, [])

# File.write!(Path.expand("./simple_thing.ex"), inspect(paths, limit: :infinity))
```

```elixir
sorted =
  Enum.sort_by(paths, fn
    {path, _} -> path
  end)
  |> IO.inspect(limit: :infinity)
```

```elixir
defmodule MapUtils do
  def deep_merge(left, right) do
    Map.merge(left, right, &deep_resolve/3)
  end

  # Key exists in both maps, and both values are maps as well.
  # These can be merged recursively.
  defp deep_resolve(_key, left = %{}, right = %{}) do
    deep_merge(left, right)
  end

  defp deep_resolve(_key, {:all, left}, {:all, right}) do
    {:all, deep_merge(left, right)}
  end

  defp deep_resolve(_key, {:all, _left}, _right) do
    raise "?"
  end

  defp deep_resolve(_key, _left, {:all, _right}) do
    raise "?2"
  end

  defp deep_resolve(_key, _left, right) do
    right
  end
end

defmodule Tree do
  def create(paths) do
    Enum.reduce(paths, %{}, fn {path, modifier}, acc ->
      leaf =
        case modifier do
          {:attr, attr} -> %{{:attr, attr} => true}
          :text -> %{text: true}
        end

      map =
        path
        # |> Enum.reverse()
        |> dedup_path([])
        # |> IO.inspect(label: :deduped)
        |> Enum.reduce(leaf, fn
          {:all, key}, accu -> %{key => {:all, accu}}
          key, accu -> %{key => accu}
        end)

      MapUtils.deep_merge(acc, map)
    end)
  end

  # dedups immediate neighbours only, also reverses the list which helps with the 
  # next steps after it.

  def dedup_path([], acc) do
    acc
  end

  def dedup_path([key], acc) do
    [key | acc]
  end

  def dedup_path([head, {:all, head} | rest], acc) do
    dedup_path([{:all, head} | rest], acc)
  end

  def dedup_path([{:all, head}, head | rest], acc) do
    dedup_path([{:all, head} | rest], acc)
  end

  def dedup_path([head, head | rest], acc) do
    # If it is duplicated then we need to drop one
    # the next will be picked up in the next iteration. 
    # I think if we have double dups this wont work, but 
    # we wont have that (I think!!)
    dedup_path([head | rest], acc)
  end

  def dedup_path([head, next | rest], acc) do
    dedup_path([next | rest], [head | acc])
  end
end

schema = Tree.create(sorted)
File.write!(Path.expand("./schmema.ex"), inspect(schema, limit: :infinity))
```

```elixir
large_xml = File.read!("/Users/Adz/Projects/data_schema/large.xml")

{:ok, simple} = DataSchema.XML.Saxy.parse_string(large_xml, schema)

File.write!(Path.expand("./simple_thing.ex"), inspect(simple, limit: :infinity))
Code.format_file!(Path.expand("./simple_thing.ex"))
# simple |> IO.inspect(limit: :infinity, printable_limit: :infinity)
{:ok, struct} = DataSchema.to_struct(simple, Duffel.Link.XMLParsing.Lufthansa.AirShopping)

# File.write!(Path.expand("./struct_res.ex"), struct)
# Code.format_file!(Path.expand("./struct_res.ex"))
```
